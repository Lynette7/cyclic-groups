// Integers mod n are cyclic. That is, if n is a positive integer then Zn is a cyclic group of order n and is generated by 1.
// This program works as follows taking into consideration the above statement:
// 1. Find the elements of the additive group mod m passed in main - additive_group(modulus)
// 2. Find the generators of the group by finding the elements that are relatively prime to m - generators(m)

// Function to find the gcd of two integers recursively
fn gcd(a: u128, b: u128) -> u128 {
    if b == 0 {
        a
    } else {
        gcd(b, a % b)
    }
}

// Function to generate the elements of an additive group
fn additive_group(modulus: u128) -> Vec<u128> {
    let mut group = Vec::new();
    for i in 0..modulus {
        group.push(i);
    }

    group
}

// Function to return all the generators in an additicve cyclic group
fn generators(m: u128) -> Vec<u128> {
    // The order of additive group Zn is n
    println!("The order of this additive group is {}", m);
    let set = additive_group(m);
    println!("The elements of the group are {:?}", &set);
    let mut generators = Vec::new();
    for &g in &set {
        let gcd = gcd(g, m);
        if gcd == 1 {
            generators.push(g);
        }
    }
    generators
}

fn main() {
    let modulus = 10;
    println!("The additive group Z{} is cyclic!", modulus);
    let generators = generators(modulus);
    println!("The generators for additive group Z{} are: {:?}", modulus, generators);
}

